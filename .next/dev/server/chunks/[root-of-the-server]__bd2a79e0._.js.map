{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/leonliu/projects/tartanhacks/app/api/vapi-webhook/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\n\n// In-memory store for agent messages (for SSE streaming)\n// In production, use Redis or similar\nlet agentMessages: Array<{ action: string; message: string; timestamp: string; data?: any }> = [];\nconst MAX_MESSAGES = 100;\n\n// POST: Receive messages from AI agent\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { action, message, data } = body;\n\n    if (!action || !message) {\n      return NextResponse.json(\n        { error: 'Missing required fields: action and message are required' },\n        { status: 400 }\n      );\n    }\n\n    // Store message with timestamp\n    const agentMessage = {\n      action,\n      message,\n      data,\n      timestamp: new Date().toISOString()\n    };\n\n    agentMessages.push(agentMessage);\n    \n    // Keep only last 100 messages\n    if (agentMessages.length > MAX_MESSAGES) {\n      agentMessages = agentMessages.slice(-MAX_MESSAGES);\n    }\n\n    console.log(`[VAPI Webhook] Received ${action}: ${message}`);\n\n    return NextResponse.json({\n      success: true,\n      message: 'Agent message received',\n      queued: agentMessages.length\n    });\n  } catch (error) {\n    console.error('VAPI webhook error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    );\n  }\n}\n\n// GET: Retrieve recent messages (for polling)\nexport async function GET(request: NextRequest) {\n  try {\n    const url = new URL(request.url);\n    const since = url.searchParams.get('since');\n    \n    let messages = agentMessages;\n    \n    // Filter by timestamp if provided\n    if (since) {\n      const sinceDate = new Date(since);\n      messages = messages.filter(msg => new Date(msg.timestamp) > sinceDate);\n    }\n\n    return NextResponse.json({\n      messages,\n      count: messages.length,\n      latest_timestamp: messages.length > 0 ? messages[messages.length - 1].timestamp : null\n    });\n  } catch (error) {\n    console.error('Error fetching VAPI messages:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch messages', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,yDAAyD;AACzD,sCAAsC;AACtC,IAAI,gBAA2F,EAAE;AACjG,MAAM,eAAe;AAGd,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG;QAElC,IAAI,CAAC,UAAU,CAAC,SAAS;YACvB,OAAO,2KAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA2D,GACpE;gBAAE,QAAQ;YAAI;QAElB;QAEA,+BAA+B;QAC/B,MAAM,eAAe;YACnB;YACA;YACA;YACA,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,cAAc,IAAI,CAAC;QAEnB,8BAA8B;QAC9B,IAAI,cAAc,MAAM,GAAG,cAAc;YACvC,gBAAgB,cAAc,KAAK,CAAC,CAAC;QACvC;QAEA,QAAQ,GAAG,CAAC,CAAC,wBAAwB,EAAE,OAAO,EAAE,EAAE,SAAS;QAE3D,OAAO,2KAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;YACT,QAAQ,cAAc,MAAM;QAC9B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO,2KAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAAyB,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAAgB,GACpG;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;QAC/B,MAAM,QAAQ,IAAI,YAAY,CAAC,GAAG,CAAC;QAEnC,IAAI,WAAW;QAEf,kCAAkC;QAClC,IAAI,OAAO;YACT,MAAM,YAAY,IAAI,KAAK;YAC3B,WAAW,SAAS,MAAM,CAAC,CAAA,MAAO,IAAI,KAAK,IAAI,SAAS,IAAI;QAC9D;QAEA,OAAO,2KAAY,CAAC,IAAI,CAAC;YACvB;YACA,OAAO,SAAS,MAAM;YACtB,kBAAkB,SAAS,MAAM,GAAG,IAAI,QAAQ,CAAC,SAAS,MAAM,GAAG,EAAE,CAAC,SAAS,GAAG;QACpF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,2KAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAA4B,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAAgB,GACvG;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}